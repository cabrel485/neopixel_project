def do_kernel_configcheck(d):
    import re, string, sys, subprocess

    # if KMETA isn't set globally by a recipe using this routine, we need to
    # set the default to 'meta'. Otherwise, kconf_check is not passed a valid
    # meta-series for processing
    kmeta = d.getVar("KMETA") or "meta"
    if not os.path.exists(kmeta):
        kmeta = "." + kmeta

    s = d.getVar('S')

    env = os.environ.copy()
    env['PATH'] = "%s:%s%s" % (d.getVar('PATH'), s, "/scripts/util/")

    try:
        configs = subprocess.check_output(['scc', '--configs', '-o', s + '/.kernel-meta'], env=env).decode('utf-8')
    except subprocess.CalledProcessError as e:
        bb.fatal( "Cannot gather config fragments for audit: %s" % e.output.decode("utf-8") )

    try:
        subprocess.check_call(['kconf_check', '--report', '-o',
                '%s/%s/cfg' % (s, kmeta), d.getVar('B') + '/.config', s, configs], cwd=s, env=env)
    except subprocess.CalledProcessError:
        # The configuration gathering can return different exit codes, but
        # we interpret them based on the KCONF_AUDIT_LEVEL variable, so we catch
        # everything here, and let the run continue.
        pass

    config_check_visibility = int(d.getVar("KCONF_AUDIT_LEVEL") or 0)
    bsp_check_visibility = int(d.getVar("KCONF_BSP_AUDIT_LEVEL") or 0)

    # if config check visibility is non-zero, report dropped configuration values
    mismatch_file = d.expand("${S}/%s/cfg/mismatch.txt" % kmeta)
    if os.path.exists(mismatch_file):
        if config_check_visibility:
            with open (mismatch_file, "r") as myfile:
                results = myfile.read()
                bb.warn( "[kernel config]: specified values did not make it into the kernel's final configuration:\n\n%s" % results)

    if bsp_check_visibility:
        invalid_file = d.expand("${S}/%s/cfg/invalid.cfg" % kmeta)
        if os.path.exists(invalid_file) and os.stat(invalid_file).st_size > 0:
            with open (invalid_file, "r") as myfile:
                results = myfile.read()
                bb.warn( "[kernel config]: This BSP sets config options that are not offered anywhere within this kernel:\n\n%s" % results)
        errors_file = d.expand("${S}/%s/cfg/fragment_errors.txt" % kmeta)
        if os.path.exists(errors_file) and os.stat(errors_file).st_size > 0:
            with open (errors_file, "r") as myfile:
               results = myfile.read()
               bb.warn( "[kernel config]: This BSP contains fragments with errors:\n\n%s" % results)

    # if the audit level is greater than two, we report if a fragment has overriden
    # a value from a base fragment. This is really only used for new kernel introduction
    if bsp_check_visibility > 2:
        redefinition_file = d.expand("${S}/%s/cfg/redefinition.txt" % kmeta)
        if os.path.exists(redefinition_file) and os.stat(redefinition_file).st_size > 0:
            with open (redefinition_file, "r") as myfile:
                results = myfile.read()
                bb.warn( "[kernel config]: This BSP has configuration options defined in more than one config, with differing values:\n\n%s" % results)

do_kernel_configcheck(d)

